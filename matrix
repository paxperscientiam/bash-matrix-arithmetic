#!/usr/bin/env bash
shopt -s nullglob
shopt -s extglob
shopt -s nocasematch


unset CDPATH

MATH_ROOT_DIR="${TMPDIR}/matrix"

if [[ ! -d $MATH_ROOT_DIR ]]; then
    mkdir "${MATH_ROOT_DIR}"
fi

__="${MATH_ROOT_DIR}"


errCheck.Matrix() {
    if [[ "${#@}" -eq 0 ]]; then
        printf 'Argument cannot be null.\n'
        return 1
    fi
    :
    if [[ ! "${1}"  =~ ^[a-zA-Z]+$ ]]; then
        printf 'Names may only include letters.\n'
        return 1
    fi
    :
    IFS=,
    for x in ${@:2}
    do
        if [[  ! $x =~ ^[0-9]+$ ]]; then
            printf 'All elements must be numeric!\n'
            return 1
        fi

    done

    return 0
}

xstCheck.Matrix() {
    :
}

unset X
unset Y

declare -A X
declare -A Y



function Matrix() {
    # Good
    errCheck.Matrix "${@}" || return 1
    xstCheck.Matrix "${1}" || return 1

    declare -r name="${1}"
    shift

    IFS=" "
    out=""
    for oo in "${@}"
    do
        out+="${oo}\\n"
    done
    out="${out%%\\n}"
    echo -e "${out}" >| "${__}/matrix.${name}"
}


function Matrix.read() {
    [[ ! -f "${__}/matrix.$1" ]] && \
        printf '%s\n' "No such matrix." && return

    while read -r p; do
        printf '%s\n' "${p}"
    done <"${__}/matrix.$1"
}

function Matrix.show() {
    # GOOD
    while IFS=, read -r p; do
        printf '[ %s ]\n' "${p}"
    done <"${__}/matrix.$1"
}

function Matrix.list() {
    local L
    L=("${__}/matrix".*)

    [[ "${#L[@]}" -eq 0 ]] && \
        printf '%s\n' "There are no matrices defined." && \
        return

    for I in "${__}/matrix".*; do
        printf '%s\n' "${I[@]/${__}\/matrix\./}"
    done
}

function Matrix.reset() {
    read -p "Delete all matrices? [y/n]" -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    local dir
    dir=$(pwd)

    cd "${__:?}" || return 1

    for I in "./matrix".*; do
        \rm "${I}"
    done

    cd "${dir}" || return 1
}


function Matrix.delete() {
    local dir
    dir=$(pwd)

    cd "${__:?}" || return 1
    :
    if [[ -f "./matrix.${1}" ]]; then
        rm "./matrix.${1}"
        printf 'Matrix %s removed from cache.\n' "${1}"
    else
        printf 'Matrix %s not found.\n' "${1}"
    fi

    cd "${dir}" || return 1

}

function Matrix.clear() {
    local dir
    dir=$(pwd)

    cd "${__:?}" || return 1
    :
    if [[ -f "./matrix.${1}" ]]; then
        printf 'null' >| "./matrix.${1}"
    fi

    cd "${dir}" || return 1
}

###### BOOLEAN OPERATIONS


function Matrix.equiv() {
    local A; A="$(Matrix.read "${1}")"
    local B; B="$(Matrix.read "${2}")"

    if [[ "${A}" == "${B}" ]]
    then
        printf 'TRUE\n' && return 0
    else
        printf 'FALSE\n'
        return 1
    fi
}





###### ARITHMETIC OPERATIONS


function Matrix.add() {
    local A; A="$(Matrix.read "${1}")"
    local B; B="$(Matrix.read "${2}")"

    local count_r; count_r=0
    local count_c; count_c=0

    IFS=$'\n'
    for A_r in ${A}; do
        echo ${A_r}
      #   IFS=" "
#         for A_el in ${A_r}; do
#            # echo "${A_el}"
#             (( count_c+=1 ))
#         done
#         (( count_r+=1 ))
    done

}

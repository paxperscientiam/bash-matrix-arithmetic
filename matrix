#!/usr/bin/env bash
shopt -s nullglob
shopt -s extglob
shopt -s nocasematch


unset CDPATH

MATH_ROOT_DIR="${TMPDIR}/matrix"

if [[ ! -d $MATH_ROOT_DIR ]]; then
    mkdir "${MATH_ROOT_DIR}"
fi

__="${MATH_ROOT_DIR}"


errCheck.Matrix() {
    if [[ "${#@}" -eq 0 ]]; then
        printf 'Argument cannot be null.\n'
        return 1
    fi
    :
    if [[ ! "${1}"  =~ ^[a-zA-Z]+$ ]]; then
        printf 'Names may only include letters.\n'
        return 1
    fi

    IFS=,
    for x in ${@:2}
    do
        if [[  ! $x =~ ^[0-9]+$ ]]; then
            printf 'All elements must be numeric!\n'
            return 1
        fi

    done

    return 0
}

xstCheck.Matrix() {
    :
}

unset X
unset Y

declare -A X
declare -A Y


function Matrix() {
    errCheck.Matrix "${@}" || return 1
    xstCheck.Matrix "${1}" || return 1


    declare -r name="${1}"
    shift

    local ni; ni=0
    local mi; mi=0

    local zv;
    local out_kv=""

    declare -A Matrix

    declare -a T=("$@")

    declare -a M

    local n; n=$((${#T[@]} - 1))
    local x; IFS=, x=(${T[0]})
    local m; m=$((${#x[@]} - 1)); unset x

    while [[ $mi -le ${m} ]]; do
        while [[ $ni -le ${n} ]]; do
            zv=(${T[ni]})
            Matrix[M${ni}${mi}]=${zv[mi]}
            eval 'eval M${ni}${mi}=${zv[mi]}'
            M+=("M${ni}${mi}")
            (( ni+=1 ))
        done
        (( ni=0 ))
        (( mi+=1 ))
    done

    out_kv=$'( '
    for k in ${!Matrix[@]}; do
        out_kv+="[${k}]=${!k} "
    done
    out_kv+=$')'

    printf '%s' "${out_kv}" >| "${__}/matrix.${name}"
}


function Matrix.read() {
   #  IFS=
    eval X='"$(<"${__}/matrix.$1")"'
    echo "${X}"
}

function Matrix.list() {
    for I in "${__}/matrix".*; do
        printf '%s\n' "${I[@]/${__}\/matrix\./}"
    done
}


function Matrix.delete() {
    :
    if [[ -f "${__}/matrix.${1}" ]]; then
        rm "${__}/matrix.${1}"
        printf 'Matrix %s removed from cache.\n' "${1}"
    else
        printf 'Matrix %s not found.\n' "${1}"
    fi
}

function Matrix.clear() {
:

}

###### BOOLEAN OPERATIONS


function Matrix.equiv() {
    local A="$(Matrix.read "${1}")"
    local B="$(Matrix.read "${2}")"

    if [[ "${A}" == "${B}" ]]
    then
        printf 'TRUE\n' && return 0
    else
        printf 'FALSE\n'
        return 1
    fi
}





###### ARITHMETIC OPERATIONS


function Matrix.add() {
    read -r $1

  #  echo "${X}"

    return
 #    local X
#     local Y

#     X=$(eval ($(Matrix.read "${1}")))

#     echo "${X[M01]}"

#     for I in "${X[@]}"
#     do
#         echo $I
#     done
#     :
}
